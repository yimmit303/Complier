[{"name":"g.txt","input":"ADDOP -> [-+]\nMULOP -> [*/]\nNUM -> \\d+\nLP -> [(]\nRP -> [)]\nID -> \\w+\n\nS -> expr \nexpr -> term expr'\nexpr' -> ADDOP term expr' | lambda\nterm -> factor term'\nterm' -> MULOP factor term' | lambda\nfactor -> id_or_func_call | NUM | LP expr RP\nid_or_func_call -> ID id_or_func_call'\nid_or_func_call' -> lambda | LP RP\n","nullable":["expr'","term'","id_or_func_call'"]},{"name":"g10.txt","input":"NUM -> \\d+\nID -> [A-Za-z]\\w*\nLP -> [(]\nRP -> [)]\nCOMMA -> ,\nADDOP -> [-+]\nMULOP -> [*/]\nEQ -> =\nSEMI -> ;\n\nprogram -> stmt SEMI program | stmt\nstmt -> assign | expr | lambda\nassign -> tuple EQ tuple2\ntuple -> tuple COMMA expr | expr \ntuple2 -> tuple2 COMMA expr | expr \nexpr -> expr ADDOP term | term\nterm -> term MULOP factor | factor\nfactor -> ID | LP expr RP | NUM\n","nullable":["stmt","program"]},{"name":"g11.txt","input":"ACT -> \\bact\\b\nROMAN_NUMERAL -> \\b(I{1,3}|IV|VI{0,3}|I?X)\\b\nADJ -> \\b(lovely|ugly|pretty|foul|handsome|disgusting)\\b\nYOU -> \\byou\\b\nARE -> are\nAS -> as\nA -> \\ba\\b\nNOUN -> \\b(king|queen|noble|crown)\\b\nACTOR -> \\b(Romeo|Juliet)\\b\nLB -> \\[\nRB -> \\]\nENTER -> enter\nEXIT -> exit\nIS -> is\nQM -> \\?\nIF -> if\nSO -> so\nCMA -> ,\nLET -> let\nUS -> us\nPROCEED -> proceed\nTO -> to\nSCENE -> scene\nOPEN -> open\nYOUR -> your\nHEART -> heart\nSPEAK -> speak\nMIND -> mind\nPUNC -> [.!]\nCOLON -> :\n\nprogram -> ACT ROMAN_NUMERAL scene_list \nadj_list -> ADJ adj_list | lambda\nassign_sentence -> YOU ARE AS ADJ AS A adj_list NOUN\nbody_list -> body_stmt body_list | lambda\nbody_stmt -> ACTOR COLON sentence_list | LB ENTER ACTOR RB | LB EXIT ACTOR RB\ncomparison_sentence -> IS ACTOR AS ADJ AS ACTOR QM\nconditional_sentence -> IF SO CMA sentence\ngoto_sentence -> LET US PROCEED TO SCENE ROMAN_NUMERAL\nio_sentence -> OPEN YOUR HEART | SPEAK YOUR MIND\nscene_list -> SCENE ROMAN_NUMERAL body_list scene_list | lambda\nsentence_list -> sentence PUNC sentence_list | lambda\nsentence -> io_sentence | assign_sentence | comparison_sentence | goto_sentence | conditional_sentence\n","nullable":["adj_list","body_list","scene_list","sentence_list"]},{"name":"g12.txt","input":"x -> x\n\nS -> A\nA -> B\nB -> C\nC -> D\nD -> E\nE -> x | lambda\n","nullable":["E","D","C","B","A","S"]},{"name":"g2.txt","input":"x -> x\n\nS -> lambda | x S x\n","nullable":["S"]},{"name":"g3.txt","input":"x -> x\n\nS -> x | x S x\n","nullable":[]},{"name":"g4.txt","input":"x -> x\n\nS -> A | B x | C\nA -> B x | C\nB -> C x | C\nC -> lambda | C | x\n","nullable":["C","S","A","B"]},{"name":"g5.txt","input":"x -> x\n\nS -> A | B x | C\nA -> B x \nB -> C x | C\nC -> lambda | C | x\n","nullable":["C","S","B"]},{"name":"g6.txt","input":"ADDOP -> [+]\nAND -> \\band\\b\nCMA -> ,\nCOMMENT -> //[^\\n]*\nDEF -> \\bdef\\b\nELSE -> \\belse\\b\nEQ -> =\nIF -> \\bif\\b\nLB -> \\[\nLBR -> [{]\nLP -> [(]\nMINUS -> -\nMULOP -> [*/]\nNOT -> \\bnot\\b\nNUM -> -?(\\d+|\\d+\\.\\d*|\\.\\d+)([Ee][-+]?\\d+)?\nNUMBER -> \\bnum\\b\nOR -> \\bor\\b\nPRINT -> \\bprint\\b\nRB -> \\]\nRBR -> [}]\nRP -> [)]\nRELOP -> >=|<=|!=|==|>|<\nRETURN -> \\breturn\\b\nSEMI -> ;\nSHIFT -> \\bshift\\b\nSTRING -> \\bstring\\b\nSTRING-CONSTANT -> \"(\\\\\"|[^\"])*\" | '(\\\\'|[^'])*'\nVAR -> \\bvar\\b\nWHILE -> \\bwhile\\b\nID -> [A-Za-z_]\\w*\n\nprogram -> var-decl-list func-decl-list\nfunc-decl-list -> func-decl func-decl-list | lambda\nfunc-decl -> DEF ID LP type-list RP optional-return-spec brace-block\noptional-return-spec -> RETURN type | lambda\nbrace-block -> LBR var-decl-list stmts RBR\ntype-list -> lambda | ID type type-list'\ntype-list' -> CMA ID type type-list' | lambda\ntype -> non-array-type | non-array-type LB size-list RB\nnon-array-type -> NUMBER | STRING\nsize-list -> NUM | NUM CMA size-list\nstmts -> stmt SEMI stmts | lambda\nstmt -> assign SEMI | func-call SEMI | loop | cond | return-stmt SEMI\nreturn-stmt -> RETURN | RETURN expr\nfunc-call -> ID LP optional-expr-list RP | builtin-func-call\nbuiltin-func-call -> PRINT LP expr-list RP | SHIFT LP expr CMA expr RP\noptional-expr-list -> lambda | expr-list\nexpr-list ->  expr expr-list'\nexpr-list' -> lambda | CMA expr expr-list'\nloop -> WHILE LP expr RP brace-block\ncond -> IF expr brace-block | IF expr brace-block ELSE brace-block\nvar-decl-list -> var-decl SEMI var-decl-list | lambda\nvar-decl -> VAR ID type\nexpr -> orexp\norexp -> orexp OR andexp | andexp\nandexp -> andexp AND notexp | notexp\nnotexp -> NOT notexp | rel\nrel -> sum RELOP sum | sum\nsum -> sum ADDOP term | sum MINUS term | term\nterm -> term MULOP neg | neg\nneg -> MINUS neg | factor\nfactor -> ID | NUM | LP expr RP | func-call | ID LB expr-list RB | STRING-CONSTANT\nassign -> ID EQ expr\n","nullable":["func-decl-list","optional-return-spec","type-list","type-list'","stmts","optional-expr-list","expr-list'","var-decl-list","program"]},{"name":"g7.txt","input":"+ -> [-+]\n* -> [*/]\n( -> [(]\n) -> [)]\nNUM -> \\d+\n\nS -> e\ne -> e + e | t\nt -> t * t | f\nf -> NUM | ( e )\n","nullable":[]},{"name":"g8.txt","input":"ADDOP -> [-+]\nMULOP -> [*/]\nNUM -> \\d+\nLP -> [(]\nRP -> [)]\nID -> \\w+\n\n\nS -> expr \nexpr -> term expr'\nexpr' -> ADDOP term expr' | lambda\nterm -> factor term'\nterm' -> MULOP factor term' | lambda\nfactor -> id_or_func_call | NUM | LP expr RP\nid_or_func_call -> ID id_or_func_call'\nid_or_func_call' -> lambda | LP RP\n","nullable":["expr'","term'","id_or_func_call'"]},{"name":"g9.txt","input":"x -> x\n\nS -> lambda | S S | x\n","nullable":["S"]}]