[{"name":"g.txt","input":"ADDOP -> [-+]\nMULOP -> [*/]\nNUM -> \\d+\nLP -> [(]\nRP -> [)]\nID -> \\w+\n\nS -> expr \nexpr -> term expr'\nexpr' -> ADDOP term expr' | lambda\nterm -> factor term'\nterm' -> MULOP factor term' | lambda\nfactor -> id_or_func_call | NUM | LP expr RP\nid_or_func_call -> ID id_or_func_call'\nid_or_func_call' -> lambda | LP RP\n","follow":{"S":["$"],"expr":["$","RP"],"expr'":["$","RP"],"term":["ADDOP","$","RP"],"term'":["ADDOP","$","RP"],"factor":["MULOP","ADDOP","$","RP"],"id_or_func_call":["MULOP","ADDOP","$","RP"],"id_or_func_call'":["MULOP","ADDOP","$","RP"]}},{"name":"g10.txt","input":"NUM -> \\d+\nID -> [A-Za-z]\\w*\nLP -> [(]\nRP -> [)]\nCOMMA -> ,\nADDOP -> [-+]\nMULOP -> [*/]\nEQ -> =\nSEMI -> ;\n\nprogram -> stmt SEMI program | stmt\nstmt -> assign | expr | lambda\nassign -> tuple EQ tuple2\ntuple -> tuple COMMA expr | expr \ntuple2 -> tuple2 COMMA expr | expr \nexpr -> expr ADDOP term | term\nterm -> term MULOP factor | factor\nfactor -> ID | LP expr RP | NUM\n","follow":{"program":["$"],"stmt":["SEMI","$"],"assign":["SEMI","$"],"tuple":["EQ","COMMA"],"tuple2":["SEMI","$","COMMA"],"expr":["SEMI","$","EQ","COMMA","ADDOP","RP"],"term":["SEMI","$","EQ","COMMA","ADDOP","MULOP","RP"],"factor":["SEMI","$","EQ","COMMA","ADDOP","MULOP","RP"]}},{"name":"g11.txt","input":"ACT -> \\bact\\b\nROMAN_NUMERAL -> \\b(I{1,3}|IV|VI{0,3}|I?X)\\b\nADJ -> \\b(lovely|ugly|pretty|foul|handsome|disgusting)\\b\nYOU -> \\byou\\b\nARE -> are\nAS -> as\nA -> \\ba\\b\nNOUN -> \\b(king|queen|noble|crown)\\b\nACTOR -> \\b(Romeo|Juliet)\\b\nLB -> \\[\nRB -> \\]\nENTER -> enter\nEXIT -> exit\nIS -> is\nQM -> \\?\nIF -> if\nSO -> so\nCMA -> ,\nLET -> let\nUS -> us\nPROCEED -> proceed\nTO -> to\nSCENE -> scene\nOPEN -> open\nYOUR -> your\nHEART -> heart\nSPEAK -> speak\nMIND -> mind\nPUNC -> [.!]\nCOLON -> :\n\nprogram -> ACT ROMAN_NUMERAL scene_list \nadj_list -> ADJ adj_list | lambda\nassign_sentence -> YOU ARE AS ADJ AS A adj_list NOUN\nbody_list -> body_stmt body_list | lambda\nbody_stmt -> ACTOR COLON sentence_list | LB ENTER ACTOR RB | LB EXIT ACTOR RB\ncomparison_sentence -> IS ACTOR AS ADJ AS ACTOR QM\nconditional_sentence -> IF SO CMA sentence\ngoto_sentence -> LET US PROCEED TO SCENE ROMAN_NUMERAL\nio_sentence -> OPEN YOUR HEART | SPEAK YOUR MIND\nscene_list -> SCENE ROMAN_NUMERAL body_list scene_list | lambda\nsentence_list -> sentence PUNC sentence_list | lambda\nsentence -> io_sentence | assign_sentence | comparison_sentence | goto_sentence | conditional_sentence\n","follow":{"program":["$"],"adj_list":["NOUN"],"assign_sentence":["PUNC"],"body_list":["SCENE","$"],"body_stmt":["ACTOR","LB","SCENE","$"],"comparison_sentence":["PUNC"],"conditional_sentence":["PUNC"],"goto_sentence":["PUNC"],"io_sentence":["PUNC"],"scene_list":["$"],"sentence_list":["ACTOR","LB","SCENE","$"],"sentence":["PUNC"]}},{"name":"g12.txt","input":"x -> x\n\nS -> A\nA -> B\nB -> C\nC -> D\nD -> E\nE -> x | lambda\n","follow":{"S":["$"],"A":["$"],"B":["$"],"C":["$"],"D":["$"],"E":["$"]}},{"name":"g2.txt","input":"x -> x\n\nS -> lambda | x S x\n","follow":{"S":["$","x"]}},{"name":"g3.txt","input":"x -> x\n\nS -> x | x S x\n","follow":{"S":["$","x"]}},{"name":"g4.txt","input":"x -> x\n\nS -> A | B x | C\nA -> B x | C\nB -> C x | C\nC -> lambda | C | x\n","follow":{"S":["$"],"A":["$"],"B":["x"],"C":["$","x"]}},{"name":"g5.txt","input":"x -> x\n\nS -> A | B x | C\nA -> B x \nB -> C x | C\nC -> lambda | C | x\n","follow":{"S":["$"],"A":["$"],"B":["x"],"C":["$","x"]}},{"name":"g6.txt","input":"ADDOP -> [+]\nAND -> \\band\\b\nCMA -> ,\nCOMMENT -> //[^\\n]*\nDEF -> \\bdef\\b\nELSE -> \\belse\\b\nEQ -> =\nIF -> \\bif\\b\nLB -> \\[\nLBR -> [{]\nLP -> [(]\nMINUS -> -\nMULOP -> [*/]\nNOT -> \\bnot\\b\nNUM -> -?(\\d+|\\d+\\.\\d*|\\.\\d+)([Ee][-+]?\\d+)?\nNUMBER -> \\bnum\\b\nOR -> \\bor\\b\nPRINT -> \\bprint\\b\nRB -> \\]\nRBR -> [}]\nRP -> [)]\nRELOP -> >=|<=|!=|==|>|<\nRETURN -> \\breturn\\b\nSEMI -> ;\nSHIFT -> \\bshift\\b\nSTRING -> \\bstring\\b\nSTRING-CONSTANT -> \"(\\\\\"|[^\"])*\" | '(\\\\'|[^'])*'\nVAR -> \\bvar\\b\nWHILE -> \\bwhile\\b\nID -> [A-Za-z_]\\w*\n\nprogram -> var-decl-list func-decl-list\nfunc-decl-list -> func-decl func-decl-list | lambda\nfunc-decl -> DEF ID LP type-list RP optional-return-spec brace-block\noptional-return-spec -> RETURN type | lambda\nbrace-block -> LBR var-decl-list stmts RBR\ntype-list -> lambda | ID type type-list'\ntype-list' -> CMA ID type type-list' | lambda\ntype -> non-array-type | non-array-type LB size-list RB\nnon-array-type -> NUMBER | STRING\nsize-list -> NUM | NUM CMA size-list\nstmts -> stmt SEMI stmts | lambda\nstmt -> assign SEMI | func-call SEMI | loop | cond | return-stmt SEMI\nreturn-stmt -> RETURN | RETURN expr\nfunc-call -> ID LP optional-expr-list RP | builtin-func-call\nbuiltin-func-call -> PRINT LP expr-list RP | SHIFT LP expr CMA expr RP\noptional-expr-list -> lambda | expr-list\nexpr-list ->  expr expr-list'\nexpr-list' -> lambda | CMA expr expr-list'\nloop -> WHILE LP expr RP brace-block\ncond -> IF expr brace-block | IF expr brace-block ELSE brace-block\nvar-decl-list -> var-decl SEMI var-decl-list | lambda\nvar-decl -> VAR ID type\nexpr -> orexp\norexp -> orexp OR andexp | andexp\nandexp -> andexp AND notexp | notexp\nnotexp -> NOT notexp | rel\nrel -> sum RELOP sum | sum\nsum -> sum ADDOP term | sum MINUS term | term\nterm -> term MULOP neg | neg\nneg -> MINUS neg | factor\nfactor -> ID | NUM | LP expr RP | func-call | ID LB expr-list RB | STRING-CONSTANT\nassign -> ID EQ expr\n","follow":{"program":["$"],"func-decl-list":["$"],"func-decl":["DEF","$"],"optional-return-spec":["LBR"],"brace-block":["DEF","$","SEMI","ELSE"],"type-list":["RP"],"type-list'":["RP"],"type":["LBR","CMA","RP","SEMI"],"non-array-type":["LBR","CMA","RP","LB","SEMI"],"size-list":["RB"],"stmts":["RBR"],"stmt":["SEMI"],"return-stmt":["SEMI"],"func-call":["SEMI","RELOP","CMA","RP","LBR","OR","AND","ADDOP","MINUS","MULOP","RB"],"builtin-func-call":["SEMI","RELOP","CMA","RP","LBR","OR","AND","ADDOP","MINUS","MULOP","RB"],"optional-expr-list":["RP"],"expr-list":["RP","RB"],"expr-list'":["RP","RB"],"loop":["SEMI"],"cond":["SEMI"],"var-decl-list":["DEF","$","ID","WHILE","IF","RETURN","PRINT","SHIFT","RBR"],"var-decl":["SEMI"],"expr":["SEMI","CMA","RP","LBR","RB"],"orexp":["SEMI","CMA","RP","LBR","OR","RB"],"andexp":["SEMI","CMA","RP","LBR","OR","AND","RB"],"notexp":["SEMI","CMA","RP","LBR","OR","AND","RB"],"rel":["SEMI","CMA","RP","LBR","OR","AND","RB"],"sum":["RELOP","SEMI","CMA","RP","LBR","OR","AND","ADDOP","MINUS","RB"],"term":["RELOP","SEMI","CMA","RP","LBR","OR","AND","ADDOP","MINUS","MULOP","RB"],"neg":["RELOP","SEMI","CMA","RP","LBR","OR","AND","ADDOP","MINUS","MULOP","RB"],"factor":["RELOP","SEMI","CMA","RP","LBR","OR","AND","ADDOP","MINUS","MULOP","RB"],"assign":["SEMI"]}},{"name":"g7.txt","input":"+ -> [-+]\n* -> [*/]\n( -> [(]\n) -> [)]\nNUM -> \\d+\n\nS -> e\ne -> e + e | t\nt -> t * t | f\nf -> NUM | ( e )\n","follow":{"S":["$"],"e":["$","+",")"],"t":["$","+","*",")"],"f":["$","+","*",")"]}},{"name":"g8.txt","input":"ADDOP -> [-+]\nMULOP -> [*/]\nNUM -> \\d+\nLP -> [(]\nRP -> [)]\nID -> \\w+\n\n\nS -> expr \nexpr -> term expr'\nexpr' -> ADDOP term expr' | lambda\nterm -> factor term'\nterm' -> MULOP factor term' | lambda\nfactor -> id_or_func_call | NUM | LP expr RP\nid_or_func_call -> ID id_or_func_call'\nid_or_func_call' -> lambda | LP RP\n","follow":{"S":["$"],"expr":["$","RP"],"expr'":["$","RP"],"term":["ADDOP","$","RP"],"term'":["ADDOP","$","RP"],"factor":["MULOP","ADDOP","$","RP"],"id_or_func_call":["MULOP","ADDOP","$","RP"],"id_or_func_call'":["MULOP","ADDOP","$","RP"]}},{"name":"g9.txt","input":"x -> x\n\nS -> lambda | S S | x\n","follow":{"S":["$","x"]}}]